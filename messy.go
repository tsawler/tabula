package tabula

import (
	"fmt"
	"os"
	"strings"

	"github.com/tsawler/tabula/core"
	"github.com/tsawler/tabula/text"
)

// CheckMessyPDF checks if the PDF exhibits traits of being "messy" or display-oriented
// (e.g. generated by Word, Quartz, or highly fragmented).
// It logs a warning to stderr if such traits are found.
func (e *Extractor) CheckMessyPDF(fragments []text.TextFragment) {
	isMessy := false
	var reasons []string

	// 1. Check Metadata
	if e.reader != nil {
		info, _ := e.reader.GetInfo()
		if info != nil {
			producer := ""
			creator := ""

			if p := info.Get("Producer"); p != nil {
				if s, ok := p.(core.String); ok {
					producer = string(s)
				}
			}
			if c := info.Get("Creator"); c != nil {
				if s, ok := c.(core.String); ok {
					creator = string(s)
				}
			}

			lowerProd := strings.ToLower(producer)
			lowerCreat := strings.ToLower(creator)

			if strings.Contains(lowerProd, "quartz") ||
				strings.Contains(lowerProd, "microsoft") ||
				strings.Contains(lowerProd, "word") {
				isMessy = true
				reasons = append(reasons, fmt.Sprintf("Producer: %s", producer))
			}

			if (strings.Contains(lowerCreat, "word") ||
				strings.Contains(lowerCreat, "powerpoint")) && !strings.Contains(strings.Join(reasons, ""), "Creator") {
				isMessy = true
				reasons = append(reasons, fmt.Sprintf("Creator: %s", creator))
			}
		}
	}

	// 2. Check Fragmentation
	if len(fragments) > 0 {
		totalChars := 0
		for _, f := range fragments {
			totalChars += len(strings.TrimSpace(f.Text))
		}
		avgChars := float64(totalChars) / float64(len(fragments))

		// Threshold: if average fragment is less than 2.5 characters, it's likely character-level or highly fragmented
		if avgChars < 2.5 {
			isMessy = true
			reasons = append(reasons, fmt.Sprintf("High fragmentation (%.2f chars/fragment)", avgChars))
		}
	}

	if isMessy {
		fmt.Fprintf(os.Stderr, "[Tabula] NOTICE: Detected 'Messy/Display-Oriented' PDF traits.\n")
		for _, r := range reasons {
			fmt.Fprintf(os.Stderr, "  - %s\n", r)
		}
	}
}
