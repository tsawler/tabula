package tabula

import (
	"fmt"
	"strings"

	"github.com/tsawler/tabula/core"
	"github.com/tsawler/tabula/text"
)

// checkMessyPDF checks if the PDF exhibits traits of being "messy" or display-oriented
// (e.g. generated by Word, Quartz, or highly fragmented).
// If such traits are found, it appends a warning to the extractor's warnings slice.
func (e *Extractor) checkMessyPDF(fragments []text.TextFragment) {
	var reasons []string

	// 1. Check Metadata
	if e.reader != nil {
		info, _ := e.reader.GetInfo()
		if info != nil {
			producer := ""
			creator := ""

			if p := info.Get("Producer"); p != nil {
				if s, ok := p.(core.String); ok {
					producer = string(s)
				}
			}
			if c := info.Get("Creator"); c != nil {
				if s, ok := c.(core.String); ok {
					creator = string(s)
				}
			}

			lowerProd := strings.ToLower(producer)
			lowerCreat := strings.ToLower(creator)

			if strings.Contains(lowerProd, "quartz") ||
				strings.Contains(lowerProd, "microsoft") ||
				strings.Contains(lowerProd, "word") {
				reasons = append(reasons, fmt.Sprintf("Producer: %s", producer))
			}

			if (strings.Contains(lowerCreat, "word") ||
				strings.Contains(lowerCreat, "powerpoint")) && !strings.Contains(strings.Join(reasons, ""), "Creator") {
				reasons = append(reasons, fmt.Sprintf("Creator: %s", creator))
			}
		}
	}

	// 2. Check Fragmentation
	if len(fragments) > 0 {
		totalChars := 0
		for _, f := range fragments {
			totalChars += len(strings.TrimSpace(f.Text))
		}
		avgChars := float64(totalChars) / float64(len(fragments))

		// Threshold: if average fragment is less than 2.5 characters, it's likely character-level or highly fragmented
		if avgChars < 2.5 {
			reasons = append(reasons, fmt.Sprintf("High fragmentation (%.2f chars/fragment)", avgChars))
		}
	}

	if len(reasons) > 0 {
		msg := fmt.Sprintf("Detected messy/display-oriented PDF traits: %s", strings.Join(reasons, ", "))
		e.warnings = append(e.warnings, Warning{
			Code:    WarningMessyPDF,
			Message: msg,
		})
	}
}
