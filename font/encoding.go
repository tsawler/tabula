package font

import (
	"strings"
	"unicode/utf8"

	"golang.org/x/text/unicode/norm"
)

// Encoding represents a character encoding that maps byte values to Unicode code points
type Encoding interface {
	// Decode converts a byte value to a Unicode rune
	Decode(b byte) rune

	// DecodeString converts a byte sequence to a Unicode string
	DecodeString(data []byte) string

	// Name returns the encoding name
	Name() string
}

// StandardEncoding implementation
type standardEncoding struct {
	name  string
	table [256]rune
}

// Decode converts a single byte to a rune using the encoding table
func (e *standardEncoding) Decode(b byte) rune {
	return e.table[b]
}

// DecodeString converts a byte sequence to a Unicode string
func (e *standardEncoding) DecodeString(data []byte) string {
	// Pre-allocate buffer - most characters are 1 rune
	runes := make([]rune, 0, len(data))

	for _, b := range data {
		r := e.table[b]
		// Skip unmapped characters (0x0000)
		if r != 0 {
			runes = append(runes, r)
		}
	}

	return string(runes)
}

// Name returns the encoding name
func (e *standardEncoding) Name() string {
	return e.name
}

// GetEncoding returns the encoding by name
func GetEncoding(name string) Encoding {
	switch name {
	case "WinAnsiEncoding":
		return WinAnsiEncoding
	case "MacRomanEncoding":
		return MacRomanEncoding
	case "PDFDocEncoding":
		return PDFDocEncoding
	case "StandardEncoding":
		return StandardEncodingTable
	case "SymbolEncoding":
		return SymbolEncoding
	case "ZapfDingbatsEncoding":
		return ZapfDingbatsEncoding
	default:
		// Default to WinAnsiEncoding for unknown encodings
		return WinAnsiEncoding
	}
}

// InferEncodingFromFontName attempts to infer the appropriate encoding from a font name
// This is a fallback strategy when the PDF doesn't specify an encoding or ToUnicode CMap
func InferEncodingFromFontName(fontName string) Encoding {
	// Normalize font name to lowercase for matching
	name := strings.ToLower(fontName)

	// Symbol fonts
	if strings.Contains(name, "symbol") {
		return SymbolEncoding
	}
	if strings.Contains(name, "zapfdingbats") || strings.Contains(name, "dingbats") {
		return ZapfDingbatsEncoding
	}
	if strings.Contains(name, "wingdings") {
		return SymbolEncoding // Wingdings uses similar symbol encoding
	}

	// CJK fonts typically use Identity-H/V (handled elsewhere)
	// These are just hints for when encoding is completely missing
	if strings.Contains(name, "mincho") || strings.Contains(name, "gothic") ||
		strings.Contains(name, "msmincho") || strings.Contains(name, "msgothic") ||
		strings.Contains(name, "heise") {
		// Japanese fonts - would need Identity-H/V with CMap
		return WinAnsiEncoding // Safe fallback
	}
	if strings.Contains(name, "simsun") || strings.Contains(name, "simhei") ||
		strings.Contains(name, "stsong") || strings.Contains(name, "stfangsong") {
		// Chinese fonts
		return WinAnsiEncoding // Safe fallback
	}
	if strings.Contains(name, "batang") || strings.Contains(name, "dotum") ||
		strings.Contains(name, "gulim") {
		// Korean fonts
		return WinAnsiEncoding // Safe fallback
	}

	// Mac fonts
	if strings.Contains(name, "menlo") || strings.Contains(name, "monaco") ||
		strings.Contains(name, "lucida") && strings.Contains(name, "grande") {
		return MacRomanEncoding
	}

	// Windows/Arial/Unicode fonts - use WinAnsi
	if strings.Contains(name, "arial") || strings.Contains(name, "unicode") ||
		strings.Contains(name, "verdana") || strings.Contains(name, "tahoma") ||
		strings.Contains(name, "calibri") || strings.Contains(name, "segoe") {
		return WinAnsiEncoding
	}

	// Times/Courier likely use StandardEncoding
	if strings.Contains(name, "times") || strings.Contains(name, "courier") ||
		strings.Contains(name, "helvetica") {
		return StandardEncodingTable
	}

	// Default fallback
	return WinAnsiEncoding
}

// NormalizeUnicode normalizes a string to NFC (Canonical Decomposition followed by Canonical Composition)
// This ensures that characters like √© are always represented as U+00E9 (precomposed)
// rather than U+0065 U+0301 (e + combining acute accent)
// This is critical for RAG applications to ensure consistent embeddings
func NormalizeUnicode(s string) string {
	return norm.NFC.String(s)
}

// DecodeWithEncoding decodes data using the specified encoding and applies Unicode normalization
func DecodeWithEncoding(data []byte, encodingName string) string {
	enc := GetEncoding(encodingName)
	decoded := enc.DecodeString(data)
	return NormalizeUnicode(decoded)
}

// CustomEncoding represents an encoding with custom differences applied to a base encoding
// This implements the PDF Differences array mechanism where specific character codes
// are overridden to map to different glyphs
type CustomEncoding struct {
	name        string
	base        Encoding
	differences map[byte]rune
}

// NewCustomEncoding creates a custom encoding by applying differences to a base encoding
// The differences map specifies byte values that should map to different runes than the base encoding
func NewCustomEncoding(base Encoding, differences map[byte]rune) *CustomEncoding {
	return &CustomEncoding{
		name:        base.Name() + "+custom",
		base:        base,
		differences: differences,
	}
}

// NewCustomEncodingFromGlyphs creates a custom encoding using glyph names instead of runes
// This matches PDF's Differences array syntax which uses glyph names
func NewCustomEncodingFromGlyphs(base Encoding, differences map[byte]string) *CustomEncoding {
	// Convert glyph names to runes
	runeDiffs := make(map[byte]rune, len(differences))
	for code, glyphName := range differences {
		if r, ok := glyphNameToUnicode[glyphName]; ok {
			runeDiffs[code] = r
		}
	}
	return NewCustomEncoding(base, runeDiffs)
}

// Decode converts a byte to a rune, using the difference if present, otherwise the base encoding
func (e *CustomEncoding) Decode(b byte) rune {
	if r, ok := e.differences[b]; ok {
		return r
	}
	return e.base.Decode(b)
}

// DecodeString converts a byte sequence to a Unicode string using custom mappings
func (e *CustomEncoding) DecodeString(data []byte) string {
	runes := make([]rune, 0, len(data))
	for _, b := range data {
		r := e.Decode(b)
		if r != 0 {
			runes = append(runes, r)
		}
	}
	return string(runes)
}

// Name returns the encoding name
func (e *CustomEncoding) Name() string {
	return e.name
}

// WinAnsiEncoding (Windows Code Page 1252) - Western European encoding
// This is the most common encoding in PDFs created on Windows
var WinAnsiEncoding = &standardEncoding{
	name:  "WinAnsiEncoding",
	table: winAnsiTable,
}

// MacRomanEncoding - Classic Mac OS encoding for Western European languages
var MacRomanEncoding = &standardEncoding{
	name:  "MacRomanEncoding",
	table: macRomanTable,
}

// PDFDocEncoding - PDF's default encoding for text strings
var PDFDocEncoding = &standardEncoding{
	name:  "PDFDocEncoding",
	table: pdfDocTable,
}

// StandardEncodingTable - Adobe StandardEncoding for Type1 fonts
var StandardEncodingTable = &standardEncoding{
	name:  "StandardEncoding",
	table: standardEncodingTableData,
}

// SymbolEncoding - Adobe Symbol font encoding
// Maps character codes to Greek letters, mathematical symbols, etc.
var SymbolEncoding = &standardEncoding{
	name:  "SymbolEncoding",
	table: symbolEncodingTable,
}

// ZapfDingbatsEncoding - Adobe ZapfDingbats font encoding
// Maps character codes to decorative symbols, arrows, etc.
var ZapfDingbatsEncoding = &standardEncoding{
	name:  "ZapfDingbatsEncoding",
	table: zapfDingbatsEncodingTable,
}

// winAnsiTable - Windows CP1252 encoding table
// Maps byte values (0-255) to Unicode code points
var winAnsiTable = [256]rune{
	// 0x00-0x1F: Control characters (most unmapped in PDFs)
	0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, // 0x00-0x07
	0x0008, 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F, // 0x08-0x0F
	0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017, // 0x10-0x17
	0x0018, 0x0019, 0x001A, 0x001B, 0x001C, 0x001D, 0x001E, 0x001F, // 0x18-0x1F

	// 0x20-0x7E: Standard ASCII
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, // 0x20-0x27  !"#$%&'
	0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, // 0x28-0x2F ()*+,-./
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, // 0x30-0x37 01234567
	0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, // 0x38-0x3F 89:;<=>?
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, // 0x40-0x47 @ABCDEFG
	0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, // 0x48-0x4F HIJKLMNO
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, // 0x50-0x57 PQRSTUVW
	0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F, // 0x58-0x5F XYZ[\]^_
	0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, // 0x60-0x67 `abcdefg
	0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, // 0x68-0x6F hijklmno
	0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, // 0x70-0x77 pqrstuvw
	0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000, // 0x78-0x7F xyz{|}~

	// 0x80-0x9F: Windows CP1252 specific characters
	0x20AC, 0x0000, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021, // 0x80-0x87 ‚Ç¨‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°
	0x02C6, 0x2030, 0x0160, 0x2039, 0x0152, 0x0000, 0x017D, 0x0000, // 0x88-0x8F ÀÜ‚Ä∞≈†‚Äπ≈í≈Ω
	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014, // 0x90-0x97 ''""‚Ä¢‚Äì‚Äî
	0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0x0000, 0x017E, 0x0178, // 0x98-0x9F Àú‚Ñ¢≈°‚Ä∫≈ì≈æ≈∏

	// 0xA0-0xFF: Extended Latin characters
	0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7, // 0xA0-0xA7  ¬°¬¢¬£¬§¬•¬¶¬ß
	0x00A8, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF, // 0xA8-0xAF ¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø
	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7, // 0xB0-0xB7 ¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑
	0x00B8, 0x00B9, 0x00BA, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF, // 0xB8-0xBF ¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø
	0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x00C7, // 0xC0-0xC7 √Ä√Å√Ç√É√Ñ√Ö√Ü√á
	0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF, // 0xC8-0xCF √à√â√ä√ã√å√ç√é√è
	0x00D0, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x00D7, // 0xD0-0xD7 √ê√ë√í√ì√î√ï√ñ√ó
	0x00D8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x00DD, 0x00DE, 0x00DF, // 0xD8-0xDF √ò√ô√ö√õ√ú√ù√û√ü
	0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7, // 0xE0-0xE7 √†√°√¢√£√§√•√¶√ß
	0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF, // 0xE8-0xEF √®√©√™√´√¨√≠√Æ√Ø
	0x00F0, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7, // 0xF0-0xF7 √∞√±√≤√≥√¥√µ√∂√∑
	0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x00FF, // 0xF8-0xFF √∏√π√∫√ª√º√Ω√æ√ø
}

// macRomanTable - Mac OS Roman encoding table
var macRomanTable = [256]rune{
	// 0x00-0x1F: Control characters
	0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
	0x0008, 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F,
	0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
	0x0018, 0x0019, 0x001A, 0x001B, 0x001C, 0x001D, 0x001E, 0x001F,

	// 0x20-0x7E: Standard ASCII (same as WinAnsi)
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
	0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
	0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F,
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
	0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
	0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F,
	0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
	0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
	0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
	0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000,

	// 0x80-0xFF: Mac Roman specific characters
	0x00C4, 0x00C5, 0x00C7, 0x00C9, 0x00D1, 0x00D6, 0x00DC, 0x00E1, // 0x80-0x87 √Ñ√Ö√á√â√ë√ñ√ú√°
	0x00E0, 0x00E2, 0x00E4, 0x00E3, 0x00E5, 0x00E7, 0x00E9, 0x00E8, // 0x88-0x8F √†√¢√§√£√•√ß√©√®
	0x00EA, 0x00EB, 0x00ED, 0x00EC, 0x00EE, 0x00EF, 0x00F1, 0x00F3, // 0x90-0x97 √™√´√≠√¨√Æ√Ø√±√≥
	0x00F2, 0x00F4, 0x00F6, 0x00F5, 0x00FA, 0x00F9, 0x00FB, 0x00FC, // 0x98-0x9F √≤√¥√∂√µ√∫√π√ª√º
	0x2020, 0x00B0, 0x00A2, 0x00A3, 0x00A7, 0x2022, 0x00B6, 0x00DF, // 0xA0-0xA7 ‚Ä†¬∞¬¢¬£¬ß‚Ä¢¬∂√ü
	0x00AE, 0x00A9, 0x2122, 0x00B4, 0x00A8, 0x2260, 0x00C6, 0x00D8, // 0xA8-0xAF ¬Æ¬©‚Ñ¢¬¥¬®‚â†√Ü√ò
	0x221E, 0x00B1, 0x2264, 0x2265, 0x00A5, 0x00B5, 0x2202, 0x2211, // 0xB0-0xB7 ‚àû¬±‚â§‚â•¬•¬µ‚àÇ‚àë
	0x220F, 0x03C0, 0x222B, 0x00AA, 0x00BA, 0x03A9, 0x00E6, 0x00F8, // 0xB8-0xBF ‚àèœÄ‚à´¬™¬∫Œ©√¶√∏
	0x00BF, 0x00A1, 0x00AC, 0x221A, 0x0192, 0x2248, 0x2206, 0x00AB, // 0xC0-0xC7 ¬ø¬°¬¨‚àö∆í‚âà‚àÜ¬´
	0x00BB, 0x2026, 0x00A0, 0x00C0, 0x00C3, 0x00D5, 0x0152, 0x0153, // 0xC8-0xCF ¬ª‚Ä¶ √Ä√É√ï≈í≈ì
	0x2013, 0x2014, 0x201C, 0x201D, 0x2018, 0x2019, 0x00F7, 0x25CA, // 0xD0-0xD7 ‚Äì‚Äî""''√∑‚óä
	0x00FF, 0x0178, 0x2044, 0x20AC, 0x2039, 0x203A, 0xFB01, 0xFB02, // 0xD8-0xDF √ø≈∏‚ÅÑ‚Ç¨‚Äπ‚Ä∫Ô¨ÅÔ¨Ç
	0x2021, 0x00B7, 0x201A, 0x201E, 0x2030, 0x00C2, 0x00CA, 0x00C1, // 0xE0-0xE7 ‚Ä°¬∑‚Äö‚Äû‚Ä∞√Ç√ä√Å
	0x00CB, 0x00C8, 0x00CD, 0x00CE, 0x00CF, 0x00CC, 0x00D3, 0x00D4, // 0xE8-0xEF √ã√à√ç√é√è√å√ì√î
	0xF8FF, 0x00D2, 0x00DA, 0x00DB, 0x00D9, 0x0131, 0x02C6, 0x02DC, // 0xF0-0xF7 √í(apple)√ö√õ√ôƒ±ÀÜÀú
	0x00AF, 0x02D8, 0x02D9, 0x02DA, 0x00B8, 0x02DD, 0x02DB, 0x02C7, // 0xF8-0xFF ¬ØÀòÀôÀö¬∏ÀùÀõÀá
}

// pdfDocTable - PDFDocEncoding table
// This is PDF's default encoding for text strings
var pdfDocTable = [256]rune{
	// 0x00-0x7F: Same as ASCII/WinAnsi
	0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
	0x0008, 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F,
	0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
	0x0018, 0x0019, 0x001A, 0x001B, 0x001C, 0x001D, 0x001E, 0x001F,
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
	0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
	0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F,
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
	0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
	0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F,
	0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
	0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
	0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
	0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000,

	// 0x80-0xFF: PDFDocEncoding specific (similar to WinAnsi but with differences)
	0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x0192, 0x2044, // 0x80-0x87 ‚Ä¢‚Ä†‚Ä°‚Ä¶‚Äî‚Äì∆í‚ÅÑ
	0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, // 0x88-0x8F ‚Äπ‚Ä∫‚àí‚Ä∞‚Äû""'
	0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x0141, 0x0152, 0x0160, // 0x90-0x97 '‚Äö‚Ñ¢Ô¨ÅÔ¨Ç≈Å≈í≈†
	0x0178, 0x017D, 0x0131, 0x0142, 0x0153, 0x0161, 0x017E, 0x0000, // 0x98-0x9F ≈∏≈Ωƒ±≈Ç≈ì≈°≈æ
	0x20AC, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7, // 0xA0-0xA7 ‚Ç¨¬°¬¢¬£¬§¬•¬¶¬ß
	0x00A8, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x0000, 0x00AE, 0x00AF, // 0xA8-0xAF ¬®¬©¬™¬´¬¨¬Æ¬Ø
	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7, // 0xB0-0xB7 ¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑
	0x00B8, 0x00B9, 0x00BA, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF, // 0xB8-0xBF ¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø
	0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x00C7, // 0xC0-0xC7 √Ä√Å√Ç√É√Ñ√Ö√Ü√á
	0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF, // 0xC8-0xCF √à√â√ä√ã√å√ç√é√è
	0x00D0, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x00D7, // 0xD0-0xD7 √ê√ë√í√ì√î√ï√ñ√ó
	0x00D8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x00DD, 0x00DE, 0x00DF, // 0xD8-0xDF √ò√ô√ö√õ√ú√ù√û√ü
	0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7, // 0xE0-0xE7 √†√°√¢√£√§√•√¶√ß
	0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF, // 0xE8-0xEF √®√©√™√´√¨√≠√Æ√Ø
	0x00F0, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7, // 0xF0-0xF7 √∞√±√≤√≥√¥√µ√∂√∑
	0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x00FF, // 0xF8-0xFF √∏√π√∫√ª√º√Ω√æ√ø
}

// standardEncodingTableData - Adobe StandardEncoding for Type1 fonts
// This is the default encoding for PostScript/Type1 fonts
var standardEncodingTableData = [256]rune{
	// 0x00-0x1F: Mostly unmapped in StandardEncoding
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

	// 0x20-0x7E: Standard ASCII
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x2019, // 0x20-0x27  !"#$%&'
	0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, // 0x28-0x2F ()*+,-./
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, // 0x30-0x37 01234567
	0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, // 0x38-0x3F 89:;<=>?
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, // 0x40-0x47 @ABCDEFG
	0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, // 0x48-0x4F HIJKLMNO
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, // 0x50-0x57 PQRSTUVW
	0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F, // 0x58-0x5F XYZ[\]^_
	0x2018, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, // 0x60-0x67 `abcdefg
	0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, // 0x68-0x6F hijklmno
	0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, // 0x70-0x77 pqrstuvw
	0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000, // 0x78-0x7F xyz{|}~

	// 0x80-0xFF: StandardEncoding extended characters (PostScript glyph names)
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x00A1, 0x00A2, 0x00A3, 0x2044, 0x00A5, 0x0192, 0x00A7, // 0xA0-0xA7  ¬°¬¢¬£‚ÅÑ¬•∆í¬ß
	0x00A4, 0x0027, 0x201C, 0x00AB, 0x2039, 0x203A, 0xFB01, 0xFB02, // 0xA8-0xAF ¬§'"¬´‚Äπ‚Ä∫Ô¨ÅÔ¨Ç
	0x0000, 0x2013, 0x2020, 0x2021, 0x00B7, 0x0000, 0x00B6, 0x2022, // 0xB0-0xB7 ‚Äì‚Ä†‚Ä°¬∑¬∂‚Ä¢
	0x201A, 0x201E, 0x201D, 0x00BB, 0x2026, 0x2030, 0x0000, 0x00BF, // 0xB8-0xBF ‚Äö‚Äû"¬ª‚Ä¶‚Ä∞¬ø
	0x0000, 0x0060, 0x00B4, 0x02C6, 0x02DC, 0x00AF, 0x02D8, 0x02D9, // 0xC0-0xC7 `¬¥ÀÜÀú¬ØÀòÀô
	0x00A8, 0x0000, 0x02DA, 0x00B8, 0x0000, 0x02DD, 0x02DB, 0x02C7, // 0xC8-0xCF ¬®Àö¬∏ÀùÀõÀá
	0x2014, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0xD0-0xD7 ‚Äî
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0xD8-0xDF
	0x0000, 0x00C6, 0x0000, 0x00AA, 0x0000, 0x0000, 0x0000, 0x0000, // 0xE0-0xE7 √Ü¬™
	0x0141, 0x00D8, 0x0152, 0x00BA, 0x0000, 0x0000, 0x0000, 0x0000, // 0xE8-0xEF ≈Å√ò≈í¬∫
	0x0000, 0x00E6, 0x0000, 0x0000, 0x0000, 0x0131, 0x0000, 0x0000, // 0xF0-0xF7 √¶ƒ±
	0x0142, 0x00F8, 0x0153, 0x00DF, 0x0000, 0x0000, 0x0000, 0x0000, // 0xF8-0xFF ≈Ç√∏≈ì√ü
}

// IsValidUTF8 checks if a string is valid UTF-8
// This is useful for detecting UTF-16BE strings (which will fail UTF-8 validation)
func IsValidUTF8(s string) bool {
	return utf8.ValidString(s)
}

// glyphNameToUnicode maps PDF glyph names to Unicode code points
// This is used by NewCustomEncodingFromGlyphs to convert Differences arrays
// Reference: Adobe Glyph List Specification
var glyphNameToUnicode = map[string]rune{
	// Common punctuation and quotes
	"space":         0x0020,
	"exclam":        0x0021,
	"quotedbl":      0x0022,
	"numbersign":    0x0023,
	"dollar":        0x0024,
	"percent":       0x0025,
	"ampersand":     0x0026,
	"quotesingle":   0x0027,
	"quoteright":    0x2019, // '
	"quoteleft":     0x2018, // '
	"quotedblleft":  0x201C, // "
	"quotedblright": 0x201D, // "
	"parenleft":     0x0028,
	"parenright":    0x0029,
	"asterisk":      0x002A,
	"plus":          0x002B,
	"comma":         0x002C,
	"hyphen":        0x002D,
	"period":        0x002E,
	"slash":         0x002F,

	// Digits
	"zero":  0x0030,
	"one":   0x0031,
	"two":   0x0032,
	"three": 0x0033,
	"four":  0x0034,
	"five":  0x0035,
	"six":   0x0036,
	"seven": 0x0037,
	"eight": 0x0038,
	"nine":  0x0039,

	// Common symbols
	"colon":        0x003A,
	"semicolon":    0x003B,
	"less":         0x003C,
	"equal":        0x003D,
	"greater":      0x003E,
	"question":     0x003F,
	"at":           0x0040,
	"bracketleft":  0x005B,
	"backslash":    0x005C,
	"bracketright": 0x005D,
	"asciicircum":  0x005E,
	"underscore":   0x005F,
	"grave":        0x0060,
	"braceleft":    0x007B,
	"bar":          0x007C,
	"braceright":   0x007D,
	"asciitilde":   0x007E,

	// Uppercase letters
	"A": 0x0041, "B": 0x0042, "C": 0x0043, "D": 0x0044,
	"E": 0x0045, "F": 0x0046, "G": 0x0047, "H": 0x0048,
	"I": 0x0049, "J": 0x004A, "K": 0x004B, "L": 0x004C,
	"M": 0x004D, "N": 0x004E, "O": 0x004F, "P": 0x0050,
	"Q": 0x0051, "R": 0x0052, "S": 0x0053, "T": 0x0054,
	"U": 0x0055, "V": 0x0056, "W": 0x0057, "X": 0x0058,
	"Y": 0x0059, "Z": 0x005A,

	// Lowercase letters
	"a": 0x0061, "b": 0x0062, "c": 0x0063, "d": 0x0064,
	"e": 0x0065, "f": 0x0066, "g": 0x0067, "h": 0x0068,
	"i": 0x0069, "j": 0x006A, "k": 0x006B, "l": 0x006C,
	"m": 0x006D, "n": 0x006E, "o": 0x006F, "p": 0x0070,
	"q": 0x0071, "r": 0x0072, "s": 0x0073, "t": 0x0074,
	"u": 0x0075, "v": 0x0076, "w": 0x0077, "x": 0x0078,
	"y": 0x0079, "z": 0x007A,

	// Currency and special symbols
	"Euro":           0x20AC, // ‚Ç¨
	"bullet":         0x2022, // ‚Ä¢
	"dagger":         0x2020, // ‚Ä†
	"daggerdbl":      0x2021, // ‚Ä°
	"ellipsis":       0x2026, // ‚Ä¶
	"emdash":         0x2014, // ‚Äî
	"endash":         0x2013, // ‚Äì
	"trademark":      0x2122, // ‚Ñ¢
	"copyright":      0x00A9, // ¬©
	"registered":     0x00AE, // ¬Æ
	"cent":           0x00A2, // ¬¢
	"sterling":       0x00A3, // ¬£
	"yen":            0x00A5, // ¬•
	"florin":         0x0192, // ∆í
	"section":        0x00A7, // ¬ß
	"paragraph":      0x00B6, // ¬∂
	"degree":         0x00B0, // ¬∞
	"exclamdown":     0x00A1, // ¬°
	"questiondown":   0x00BF, // ¬ø
	"guillemotleft":  0x00AB, // ¬´
	"guillemotright": 0x00BB, // ¬ª
	"guilsinglleft":  0x2039, // ‚Äπ
	"guilsinglright": 0x203A, // ‚Ä∫

	// Accented characters - Latin-1 supplement
	"Agrave":      0x00C0, // √Ä
	"Aacute":      0x00C1, // √Å
	"Acircumflex": 0x00C2, // √Ç
	"Atilde":      0x00C3, // √É
	"Adieresis":   0x00C4, // √Ñ
	"Aring":       0x00C5, // √Ö
	"AE":          0x00C6, // √Ü
	"Ccedilla":    0x00C7, // √á
	"Egrave":      0x00C8, // √à
	"Eacute":      0x00C9, // √â
	"Ecircumflex": 0x00CA, // √ä
	"Edieresis":   0x00CB, // √ã
	"Igrave":      0x00CC, // √å
	"Iacute":      0x00CD, // √ç
	"Icircumflex": 0x00CE, // √é
	"Idieresis":   0x00CF, // √è
	"Eth":         0x00D0, // √ê
	"Ntilde":      0x00D1, // √ë
	"Ograve":      0x00D2, // √í
	"Oacute":      0x00D3, // √ì
	"Ocircumflex": 0x00D4, // √î
	"Otilde":      0x00D5, // √ï
	"Odieresis":   0x00D6, // √ñ
	"Oslash":      0x00D8, // √ò
	"Ugrave":      0x00D9, // √ô
	"Uacute":      0x00DA, // √ö
	"Ucircumflex": 0x00DB, // √õ
	"Udieresis":   0x00DC, // √ú
	"Yacute":      0x00DD, // √ù
	"Thorn":       0x00DE, // √û
	"germandbls":  0x00DF, // √ü

	"agrave":      0x00E0, // √†
	"aacute":      0x00E1, // √°
	"acircumflex": 0x00E2, // √¢
	"atilde":      0x00E3, // √£
	"adieresis":   0x00E4, // √§
	"aring":       0x00E5, // √•
	"ae":          0x00E6, // √¶
	"ccedilla":    0x00E7, // √ß
	"egrave":      0x00E8, // √®
	"eacute":      0x00E9, // √©
	"ecircumflex": 0x00EA, // √™
	"edieresis":   0x00EB, // √´
	"igrave":      0x00EC, // √¨
	"iacute":      0x00ED, // √≠
	"icircumflex": 0x00EE, // √Æ
	"idieresis":   0x00EF, // √Ø
	"eth":         0x00F0, // √∞
	"ntilde":      0x00F1, // √±
	"ograve":      0x00F2, // √≤
	"oacute":      0x00F3, // √≥
	"ocircumflex": 0x00F4, // √¥
	"otilde":      0x00F5, // √µ
	"odieresis":   0x00F6, // √∂
	"oslash":      0x00F8, // √∏
	"ugrave":      0x00F9, // √π
	"uacute":      0x00FA, // √∫
	"ucircumflex": 0x00FB, // √ª
	"udieresis":   0x00FC, // √º
	"yacute":      0x00FD, // √Ω
	"thorn":       0x00FE, // √æ
	"ydieresis":   0x00FF, // √ø

	// Fractions
	"fraction":      0x2044, // ‚ÅÑ
	"onehalf":       0x00BD, // ¬Ω
	"onequarter":    0x00BC, // ¬º
	"threequarters": 0x00BE, // ¬æ

	// Math and technical
	"minus":        0x2212, // ‚àí
	"multiply":     0x00D7, // √ó
	"divide":       0x00F7, // √∑
	"plusminus":    0x00B1, // ¬±
	"notequal":     0x2260, // ‚â†
	"lessequal":    0x2264, // ‚â§
	"greaterequal": 0x2265, // ‚â•
	"mu":           0x00B5, // ¬µ
	"partialdiff":  0x2202, // ‚àÇ
	"summation":    0x2211, // ‚àë
	"product":      0x220F, // ‚àè
	"pi":           0x03C0, // œÄ
	"integral":     0x222B, // ‚à´
	"Omega":        0x03A9, // Œ©
	"infinity":     0x221E, // ‚àû
	"radical":      0x221A, // ‚àö
	"approxequal":  0x2248, // ‚âà
}

// symbolEncodingTable - Adobe Symbol font encoding
// Maps byte values to Greek letters, mathematical symbols, etc.
// Based on Adobe's Symbol font encoding
var symbolEncodingTable = [256]rune{
	// 0x00-0x1F: Control characters
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

	// 0x20-0x7E: Symbol font characters
	0x0020, 0x0021, 0x2200, 0x0023, 0x2203, 0x0025, 0x0026, 0x220B, // ' !"#‚àÉ%&‚àã
	0x0028, 0x0029, 0x2217, 0x002B, 0x002C, 0x2212, 0x002E, 0x002F, // ()*+,‚àí./
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, // 01234567
	0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, // 89:;<=>?
	0x2245, 0x0391, 0x0392, 0x03A7, 0x0394, 0x0395, 0x03A6, 0x0393, // ‚âÖŒëŒíŒßŒîŒïŒ¶Œì
	0x0397, 0x0399, 0x03D1, 0x039A, 0x039B, 0x039C, 0x039D, 0x039F, // ŒóŒôŒòŒöŒõŒúŒùŒü
	0x03A0, 0x0398, 0x03A1, 0x03A3, 0x03A4, 0x03A5, 0x03C2, 0x03A9, // Œ†ŒòŒ°Œ£Œ§Œ•œπŒ©
	0x039E, 0x03A8, 0x0396, 0x005B, 0x2234, 0x005D, 0x22A5, 0x005F, // ŒûŒ®Œñ[‚à¥]‚ä•_
	0xF8E5, 0x03B1, 0x03B2, 0x03C7, 0x03B4, 0x03B5, 0x03C6, 0x03B3, // Œ±Œ≤œáŒ¥ŒµœÜŒ≥
	0x03B7, 0x03B9, 0x03D5, 0x03BA, 0x03BB, 0x03BC, 0x03BD, 0x03BF, // Œ∑ŒπœïŒ∫ŒªŒºŒΩŒø
	0x03C0, 0x03B8, 0x03C1, 0x03C3, 0x03C4, 0x03C5, 0x03D6, 0x03C9, // œÄŒ∏œÅœÉœÑœÖœñœâ
	0x03BE, 0x03C8, 0x03B6, 0x007B, 0x007C, 0x007D, 0x223C, 0x0000, // ŒæœàŒ∂{|}~

	// 0x80-0xFF: Extended symbol characters
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x00A0, 0x03D2, 0x2032, 0x2264, 0x2044, 0x221E, 0x0192, 0x2663, // œí‚Ä≤‚â§‚ÅÑ‚àû∆í‚ô£
	0x2666, 0x2665, 0x2660, 0x2194, 0x2190, 0x2191, 0x2192, 0x2193, // ‚ô¶‚ô•‚ô†‚Üî‚Üê‚Üë‚Üí‚Üì
	0x00B0, 0x00B1, 0x2033, 0x2265, 0x00D7, 0x221D, 0x2202, 0x2022, // ¬∞¬±‚Ä≥‚â•√ó‚àù‚àÇ‚Ä¢
	0x00F7, 0x2260, 0x2261, 0x2248, 0x2026, 0x23D0, 0x23AF, 0x21B5, // √∑‚â†‚â°‚âà‚Ä¶‚èê‚éØ‚Üµ
	0x2135, 0x2111, 0x211C, 0x2118, 0x2297, 0x2295, 0x2205, 0x2229, // ‚Ñµ‚Ñë‚Ñú‚Ñò‚äó‚äï‚àÖ‚à©
	0x222A, 0x2283, 0x2287, 0x2284, 0x2282, 0x2286, 0x2208, 0x2209, // ‚à™‚äÉ‚äá‚äÑ‚äÇ‚äÜ‚àà‚àâ
	0x2220, 0x2207, 0x00AE, 0x00A9, 0x2122, 0x220F, 0x221A, 0x22C5, // ‚à†‚àá¬Æ¬©‚Ñ¢‚àè‚àö‚ãÖ
	0x00AC, 0x2227, 0x2228, 0x21D4, 0x21D0, 0x21D1, 0x21D2, 0x21D3, // ¬¨‚àß‚à®‚áî‚áê‚áë‚áí‚áì
	0x25CA, 0x3008, 0x00AE, 0x00A9, 0x2122, 0x2211, 0x239B, 0x239C, // ‚óä„Äà¬Æ¬©‚Ñ¢‚àë‚éõ‚éú
	0x239D, 0x23A1, 0x23A2, 0x23A3, 0x23A7, 0x23A8, 0x23A9, 0x23AA, // ‚éù‚é°‚é¢‚é£‚éß‚é®‚é©‚é™
	0xF8FF, 0x3009, 0x222B, 0x2320, 0x23AE, 0x2321, 0x239E, 0x239F, // „Äâ‚à´‚å†‚éÆ‚å°‚éû‚éü
	0x23A0, 0x23A4, 0x23A5, 0x23A6, 0x23AB, 0x23AC, 0x23AD, 0x0000, // ‚é†‚é§‚é•‚é¶‚é´‚é¨‚é≠
}

// zapfDingbatsEncodingTable - Adobe ZapfDingbats font encoding
// Maps byte values to decorative symbols, arrows, numbers in circles, etc.
var zapfDingbatsEncodingTable = [256]rune{
	// 0x00-0x1F: Control characters
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

	// 0x20-0x7E: Dingbats characters
	0x0020, 0x2701, 0x2702, 0x2703, 0x2704, 0x260E, 0x2706, 0x2707, // ‚úÅ‚úÇ‚úÉ‚úÑ‚òé‚úÜ‚úá
	0x2708, 0x2709, 0x261B, 0x261E, 0x270C, 0x270D, 0x270E, 0x270F, // ‚úà‚úâ‚òõ‚òû‚úå‚úç‚úé‚úè
	0x2710, 0x2711, 0x2712, 0x2713, 0x2714, 0x2715, 0x2716, 0x2717, // ‚úê‚úë‚úí‚úì‚úî‚úï‚úñ‚úó
	0x2718, 0x2719, 0x271A, 0x271B, 0x271C, 0x271D, 0x271E, 0x271F, // ‚úò‚úô‚úö‚úõ‚úú‚úù‚úû‚úü
	0x2720, 0x2721, 0x2722, 0x2723, 0x2724, 0x2725, 0x2726, 0x2727, // ‚ú†‚ú°‚ú¢‚ú£‚ú§‚ú•‚ú¶‚úß
	0x2605, 0x2729, 0x272A, 0x272B, 0x272C, 0x272D, 0x272E, 0x272F, // ‚òÖ‚ú©‚ú™‚ú´‚ú¨‚ú≠‚úÆ‚úØ
	0x2730, 0x2731, 0x2732, 0x2733, 0x2734, 0x2735, 0x2736, 0x2737, // ‚ú∞‚ú±‚ú≤‚ú≥‚ú¥‚úµ‚ú∂‚ú∑
	0x2738, 0x2739, 0x273A, 0x273B, 0x273C, 0x273D, 0x273E, 0x273F, // ‚ú∏‚úπ‚ú∫‚úª‚úº‚úΩ‚úæ‚úø
	0x2740, 0x2741, 0x2742, 0x2743, 0x2744, 0x2745, 0x2746, 0x2747, // ‚ùÄ‚ùÅ‚ùÇ‚ùÉ‚ùÑ‚ùÖ‚ùÜ‚ùá
	0x2748, 0x2749, 0x274A, 0x274B, 0x25CF, 0x274D, 0x25A0, 0x274F, // ‚ùà‚ùâ‚ùä‚ùã‚óè‚ùç‚ñ†‚ùè
	0x2750, 0x2751, 0x2752, 0x25B2, 0x25BC, 0x25C6, 0x2756, 0x25D7, // ‚ùê‚ùë‚ùí‚ñ≤‚ñº‚óÜ‚ùñ‚óó
	0x2758, 0x2759, 0x275A, 0x275B, 0x275C, 0x275D, 0x275E, 0x0000, // ‚ùò‚ùô‚ùö‚ùõ‚ùú‚ùù‚ùû

	// 0x80-0xFF: Extended dingbats
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x2761, 0x2762, 0x2763, 0x2764, 0x2765, 0x2766, 0x2767, // ‚ù°‚ù¢‚ù£‚ù§‚ù•‚ù¶‚ùß
	0x2663, 0x2666, 0x2665, 0x2660, 0x2460, 0x2461, 0x2462, 0x2463, // ‚ô£‚ô¶‚ô•‚ô†‚ë†‚ë°‚ë¢‚ë£
	0x2464, 0x2465, 0x2466, 0x2467, 0x2468, 0x2469, 0x2776, 0x2777, // ‚ë§‚ë•‚ë¶‚ëß‚ë®‚ë©‚ù∂‚ù∑
	0x2778, 0x2779, 0x277A, 0x277B, 0x277C, 0x277D, 0x277E, 0x277F, // ‚ù∏‚ùπ‚ù∫‚ùª‚ùº‚ùΩ‚ùæ‚ùø
	0x2780, 0x2781, 0x2782, 0x2783, 0x2784, 0x2785, 0x2786, 0x2787, // ‚ûÄ‚ûÅ‚ûÇ‚ûÉ‚ûÑ‚ûÖ‚ûÜ‚ûá
	0x2788, 0x2789, 0x278A, 0x278B, 0x278C, 0x278D, 0x278E, 0x278F, // ‚ûà‚ûâ‚ûä‚ûã‚ûå‚ûç‚ûé‚ûè
	0x2790, 0x2791, 0x2792, 0x2793, 0x2794, 0x2192, 0x2194, 0x2195, // ‚ûê‚ûë‚ûí‚ûì‚ûî‚Üí‚Üî‚Üï
	0x2798, 0x2799, 0x279A, 0x279B, 0x279C, 0x279D, 0x279E, 0x279F, // ‚ûò‚ûô‚ûö‚ûõ‚ûú‚ûù‚ûû‚ûü
	0x27A0, 0x27A1, 0x27A2, 0x27A3, 0x27A4, 0x27A5, 0x27A6, 0x27A7, // ‚û†‚û°‚û¢‚û£‚û§‚û•‚û¶‚ûß
	0x27A8, 0x27A9, 0x27AA, 0x27AB, 0x27AC, 0x27AD, 0x27AE, 0x27AF, // ‚û®‚û©‚û™‚û´‚û¨‚û≠‚ûÆ‚ûØ
	0x0000, 0x27B1, 0x27B2, 0x27B3, 0x27B4, 0x27B5, 0x27B6, 0x27B7, // ‚û±‚û≤‚û≥‚û¥‚ûµ‚û∂‚û∑
	0x27B8, 0x27B9, 0x27BA, 0x27BB, 0x27BC, 0x27BD, 0x27BE, 0x0000, // ‚û∏‚ûπ‚û∫‚ûª‚ûº‚ûΩ‚ûæ
}

// IsEmojiSequence checks if a string contains emoji sequences
// Emoji can be multi-codepoint: base + modifiers (skin tone) + ZWJ sequences
func IsEmojiSequence(s string) bool {
	for _, r := range s {
		// Check for emoji ranges and special characters
		if isEmojiCodepoint(r) {
			return true
		}
	}
	return false
}

// isEmojiCodepoint checks if a rune is an emoji or emoji-related character
func isEmojiCodepoint(r rune) bool {
	// Emoji ranges (simplified - covers most common emoji)
	return (r >= 0x1F300 && r <= 0x1F9FF) || // Misc Symbols and Pictographs, Emoticons, Transport, etc.
		(r >= 0x2600 && r <= 0x26FF) || // Misc Symbols (‚òÄÔ∏è sun, etc.)
		(r >= 0x2700 && r <= 0x27BF) || // Dingbats
		(r >= 0x2B00 && r <= 0x2BFF) || // Misc Symbols and Arrows (‚≠ê star, etc.)
		(r >= 0xFE00 && r <= 0xFE0F) || // Variation selectors
		(r == 0x200D) || // Zero Width Joiner (ZWJ)
		(r >= 0x1F1E6 && r <= 0x1F1FF) // Regional indicators (flags)
}

// NormalizeEmojiSequence normalizes emoji sequences for consistent storage
// This handles skin tone modifiers and ZWJ sequences
func NormalizeEmojiSequence(s string) string {
	// For now, just return the string as-is
	// Full emoji normalization would require:
	// 1. Detecting ZWJ sequences (üë®‚Äçüë©‚Äçüëß‚Äçüë¶)
	// 2. Handling skin tone modifiers (üëãüèΩ)
	// 3. Normalizing variation selectors
	// This is a placeholder for future enhancement
	return s
}

// DecodeUTF16BE decodes UTF-16 Big Endian encoded bytes to a string
// Note: Input should NOT include the BOM (FEFF) - that should be stripped before calling
func DecodeUTF16BE(data []byte) string {
	if len(data) == 0 {
		return ""
	}

	// Ensure we have pairs of bytes
	if len(data)%2 != 0 {
		// Pad with zero if odd length
		data = append(data, 0)
	}

	runes := make([]rune, 0, len(data)/2)

	for i := 0; i < len(data); i += 2 {
		// Read big-endian 16-bit value
		codeUnit := uint16(data[i])<<8 | uint16(data[i+1])

		// Check if this is a high surrogate (D800-DBFF)
		if codeUnit >= 0xD800 && codeUnit <= 0xDBFF {
			// This is a high surrogate - need to read low surrogate
			if i+2 < len(data) {
				lowSurrogate := uint16(data[i+2])<<8 | uint16(data[i+3])
				if lowSurrogate >= 0xDC00 && lowSurrogate <= 0xDFFF {
					// Valid surrogate pair - decode to codepoint
					codepoint := 0x10000 + ((uint32(codeUnit)-0xD800)<<10 | (uint32(lowSurrogate) - 0xDC00))
					runes = append(runes, rune(codepoint))
					i += 2 // Skip the low surrogate
					continue
				}
			}
			// Invalid surrogate - skip it
			continue
		}

		// Check if this is a low surrogate without a high surrogate (invalid)
		if codeUnit >= 0xDC00 && codeUnit <= 0xDFFF {
			// Invalid - skip it
			continue
		}

		// Normal BMP character
		runes = append(runes, rune(codeUnit))
	}

	return string(runes)
}

// DecodeUTF16LE decodes UTF-16 Little Endian encoded bytes to a string
// Note: Input should NOT include the BOM (FFFE) - that should be stripped before calling
func DecodeUTF16LE(data []byte) string {
	if len(data) == 0 {
		return ""
	}

	// Ensure we have pairs of bytes
	if len(data)%2 != 0 {
		// Pad with zero if odd length
		data = append(data, 0)
	}

	runes := make([]rune, 0, len(data)/2)

	for i := 0; i < len(data); i += 2 {
		// Read little-endian 16-bit value
		codeUnit := uint16(data[i]) | uint16(data[i+1])<<8

		// Check if this is a high surrogate (D800-DBFF)
		if codeUnit >= 0xD800 && codeUnit <= 0xDBFF {
			// This is a high surrogate - need to read low surrogate
			if i+2 < len(data) {
				lowSurrogate := uint16(data[i+2]) | uint16(data[i+3])<<8
				if lowSurrogate >= 0xDC00 && lowSurrogate <= 0xDFFF {
					// Valid surrogate pair - decode to codepoint
					codepoint := 0x10000 + ((uint32(codeUnit)-0xD800)<<10 | (uint32(lowSurrogate) - 0xDC00))
					runes = append(runes, rune(codepoint))
					i += 2 // Skip the low surrogate
					continue
				}
			}
			// Invalid surrogate - skip it
			continue
		}

		// Check if this is a low surrogate without a high surrogate (invalid)
		if codeUnit >= 0xDC00 && codeUnit <= 0xDFFF {
			// Invalid - skip it
			continue
		}

		// Normal BMP character
		runes = append(runes, rune(codeUnit))
	}

	return string(runes)
}
