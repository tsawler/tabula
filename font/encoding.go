package font

import (
	"unicode/utf8"

	"golang.org/x/text/unicode/norm"
)

// Encoding represents a character encoding that maps byte values to Unicode code points
type Encoding interface {
	// Decode converts a byte value to a Unicode rune
	Decode(b byte) rune

	// DecodeString converts a byte sequence to a Unicode string
	DecodeString(data []byte) string

	// Name returns the encoding name
	Name() string
}

// StandardEncoding implementation
type standardEncoding struct {
	name  string
	table [256]rune
}

// Decode converts a single byte to a rune using the encoding table
func (e *standardEncoding) Decode(b byte) rune {
	return e.table[b]
}

// DecodeString converts a byte sequence to a Unicode string
func (e *standardEncoding) DecodeString(data []byte) string {
	// Pre-allocate buffer - most characters are 1 rune
	runes := make([]rune, 0, len(data))

	for _, b := range data {
		r := e.table[b]
		// Skip unmapped characters (0x0000)
		if r != 0 {
			runes = append(runes, r)
		}
	}

	return string(runes)
}

// Name returns the encoding name
func (e *standardEncoding) Name() string {
	return e.name
}

// GetEncoding returns the encoding by name
func GetEncoding(name string) Encoding {
	switch name {
	case "WinAnsiEncoding":
		return WinAnsiEncoding
	case "MacRomanEncoding":
		return MacRomanEncoding
	case "PDFDocEncoding":
		return PDFDocEncoding
	case "StandardEncoding":
		return StandardEncodingTable
	default:
		// Default to WinAnsiEncoding for unknown encodings
		return WinAnsiEncoding
	}
}

// NormalizeUnicode normalizes a string to NFC (Canonical Decomposition followed by Canonical Composition)
// This ensures that characters like é are always represented as U+00E9 (precomposed)
// rather than U+0065 U+0301 (e + combining acute accent)
// This is critical for RAG applications to ensure consistent embeddings
func NormalizeUnicode(s string) string {
	return norm.NFC.String(s)
}

// DecodeWithEncoding decodes data using the specified encoding and applies Unicode normalization
func DecodeWithEncoding(data []byte, encodingName string) string {
	enc := GetEncoding(encodingName)
	decoded := enc.DecodeString(data)
	return NormalizeUnicode(decoded)
}

// CustomEncoding represents an encoding with custom differences applied to a base encoding
// This implements the PDF Differences array mechanism where specific character codes
// are overridden to map to different glyphs
type CustomEncoding struct {
	name        string
	base        Encoding
	differences map[byte]rune
}

// NewCustomEncoding creates a custom encoding by applying differences to a base encoding
// The differences map specifies byte values that should map to different runes than the base encoding
func NewCustomEncoding(base Encoding, differences map[byte]rune) *CustomEncoding {
	return &CustomEncoding{
		name:        base.Name() + "+custom",
		base:        base,
		differences: differences,
	}
}

// NewCustomEncodingFromGlyphs creates a custom encoding using glyph names instead of runes
// This matches PDF's Differences array syntax which uses glyph names
func NewCustomEncodingFromGlyphs(base Encoding, differences map[byte]string) *CustomEncoding {
	// Convert glyph names to runes
	runeDiffs := make(map[byte]rune, len(differences))
	for code, glyphName := range differences {
		if r, ok := glyphNameToUnicode[glyphName]; ok {
			runeDiffs[code] = r
		}
	}
	return NewCustomEncoding(base, runeDiffs)
}

// Decode converts a byte to a rune, using the difference if present, otherwise the base encoding
func (e *CustomEncoding) Decode(b byte) rune {
	if r, ok := e.differences[b]; ok {
		return r
	}
	return e.base.Decode(b)
}

// DecodeString converts a byte sequence to a Unicode string using custom mappings
func (e *CustomEncoding) DecodeString(data []byte) string {
	runes := make([]rune, 0, len(data))
	for _, b := range data {
		r := e.Decode(b)
		if r != 0 {
			runes = append(runes, r)
		}
	}
	return string(runes)
}

// Name returns the encoding name
func (e *CustomEncoding) Name() string {
	return e.name
}

// WinAnsiEncoding (Windows Code Page 1252) - Western European encoding
// This is the most common encoding in PDFs created on Windows
var WinAnsiEncoding = &standardEncoding{
	name:  "WinAnsiEncoding",
	table: winAnsiTable,
}

// MacRomanEncoding - Classic Mac OS encoding for Western European languages
var MacRomanEncoding = &standardEncoding{
	name:  "MacRomanEncoding",
	table: macRomanTable,
}

// PDFDocEncoding - PDF's default encoding for text strings
var PDFDocEncoding = &standardEncoding{
	name:  "PDFDocEncoding",
	table: pdfDocTable,
}

// StandardEncodingTable - Adobe StandardEncoding for Type1 fonts
var StandardEncodingTable = &standardEncoding{
	name:  "StandardEncoding",
	table: standardEncodingTableData,
}

// winAnsiTable - Windows CP1252 encoding table
// Maps byte values (0-255) to Unicode code points
var winAnsiTable = [256]rune{
	// 0x00-0x1F: Control characters (most unmapped in PDFs)
	0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, // 0x00-0x07
	0x0008, 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F, // 0x08-0x0F
	0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017, // 0x10-0x17
	0x0018, 0x0019, 0x001A, 0x001B, 0x001C, 0x001D, 0x001E, 0x001F, // 0x18-0x1F

	// 0x20-0x7E: Standard ASCII
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027, // 0x20-0x27  !"#$%&'
	0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, // 0x28-0x2F ()*+,-./
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, // 0x30-0x37 01234567
	0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, // 0x38-0x3F 89:;<=>?
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, // 0x40-0x47 @ABCDEFG
	0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, // 0x48-0x4F HIJKLMNO
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, // 0x50-0x57 PQRSTUVW
	0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F, // 0x58-0x5F XYZ[\]^_
	0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, // 0x60-0x67 `abcdefg
	0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, // 0x68-0x6F hijklmno
	0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, // 0x70-0x77 pqrstuvw
	0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000, // 0x78-0x7F xyz{|}~

	// 0x80-0x9F: Windows CP1252 specific characters
	0x20AC, 0x0000, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021, // 0x80-0x87 €‚ƒ„…†‡
	0x02C6, 0x2030, 0x0160, 0x2039, 0x0152, 0x0000, 0x017D, 0x0000, // 0x88-0x8F ˆ‰Š‹ŒŽ
	0x0000, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014, // 0x90-0x97 ''""•–—
	0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0x0000, 0x017E, 0x0178, // 0x98-0x9F ˜™š›œžŸ

	// 0xA0-0xFF: Extended Latin characters
	0x00A0, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7, // 0xA0-0xA7  ¡¢£¤¥¦§
	0x00A8, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x00AF, // 0xA8-0xAF ¨©ª«¬­®¯
	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7, // 0xB0-0xB7 °±²³´µ¶·
	0x00B8, 0x00B9, 0x00BA, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF, // 0xB8-0xBF ¸¹º»¼½¾¿
	0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x00C7, // 0xC0-0xC7 ÀÁÂÃÄÅÆÇ
	0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF, // 0xC8-0xCF ÈÉÊËÌÍÎÏ
	0x00D0, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x00D7, // 0xD0-0xD7 ÐÑÒÓÔÕÖ×
	0x00D8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x00DD, 0x00DE, 0x00DF, // 0xD8-0xDF ØÙÚÛÜÝÞß
	0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7, // 0xE0-0xE7 àáâãäåæç
	0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF, // 0xE8-0xEF èéêëìíîï
	0x00F0, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7, // 0xF0-0xF7 ðñòóôõö÷
	0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x00FF, // 0xF8-0xFF øùúûüýþÿ
}

// macRomanTable - Mac OS Roman encoding table
var macRomanTable = [256]rune{
	// 0x00-0x1F: Control characters
	0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
	0x0008, 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F,
	0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
	0x0018, 0x0019, 0x001A, 0x001B, 0x001C, 0x001D, 0x001E, 0x001F,

	// 0x20-0x7E: Standard ASCII (same as WinAnsi)
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
	0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
	0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F,
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
	0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
	0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F,
	0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
	0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
	0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
	0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000,

	// 0x80-0xFF: Mac Roman specific characters
	0x00C4, 0x00C5, 0x00C7, 0x00C9, 0x00D1, 0x00D6, 0x00DC, 0x00E1, // 0x80-0x87 ÄÅÇÉÑÖÜá
	0x00E0, 0x00E2, 0x00E4, 0x00E3, 0x00E5, 0x00E7, 0x00E9, 0x00E8, // 0x88-0x8F àâäãåçéè
	0x00EA, 0x00EB, 0x00ED, 0x00EC, 0x00EE, 0x00EF, 0x00F1, 0x00F3, // 0x90-0x97 êëíìîïñó
	0x00F2, 0x00F4, 0x00F6, 0x00F5, 0x00FA, 0x00F9, 0x00FB, 0x00FC, // 0x98-0x9F òôöõúùûü
	0x2020, 0x00B0, 0x00A2, 0x00A3, 0x00A7, 0x2022, 0x00B6, 0x00DF, // 0xA0-0xA7 †°¢£§•¶ß
	0x00AE, 0x00A9, 0x2122, 0x00B4, 0x00A8, 0x2260, 0x00C6, 0x00D8, // 0xA8-0xAF ®©™´¨≠ÆØ
	0x221E, 0x00B1, 0x2264, 0x2265, 0x00A5, 0x00B5, 0x2202, 0x2211, // 0xB0-0xB7 ∞±≤≥¥µ∂∑
	0x220F, 0x03C0, 0x222B, 0x00AA, 0x00BA, 0x03A9, 0x00E6, 0x00F8, // 0xB8-0xBF ∏π∫ªºΩæø
	0x00BF, 0x00A1, 0x00AC, 0x221A, 0x0192, 0x2248, 0x2206, 0x00AB, // 0xC0-0xC7 ¿¡¬√ƒ≈∆«
	0x00BB, 0x2026, 0x00A0, 0x00C0, 0x00C3, 0x00D5, 0x0152, 0x0153, // 0xC8-0xCF »… ÀÃÕŒœ
	0x2013, 0x2014, 0x201C, 0x201D, 0x2018, 0x2019, 0x00F7, 0x25CA, // 0xD0-0xD7 –—""''÷◊
	0x00FF, 0x0178, 0x2044, 0x20AC, 0x2039, 0x203A, 0xFB01, 0xFB02, // 0xD8-0xDF ÿŸ⁄€‹›ﬁﬂ
	0x2021, 0x00B7, 0x201A, 0x201E, 0x2030, 0x00C2, 0x00CA, 0x00C1, // 0xE0-0xE7 ‡·‚„‰ÂÊÁ
	0x00CB, 0x00C8, 0x00CD, 0x00CE, 0x00CF, 0x00CC, 0x00D3, 0x00D4, // 0xE8-0xEF ËÈÍÎÏÌÓÔ
	0xF8FF, 0x00D2, 0x00DA, 0x00DB, 0x00D9, 0x0131, 0x02C6, 0x02DC, // 0xF0-0xF7 Ò(apple)ÚÛÙıˆ˜
	0x00AF, 0x02D8, 0x02D9, 0x02DA, 0x00B8, 0x02DD, 0x02DB, 0x02C7, // 0xF8-0xFF ¯˘˙˚¸˝˛ˇ
}

// pdfDocTable - PDFDocEncoding table
// This is PDF's default encoding for text strings
var pdfDocTable = [256]rune{
	// 0x00-0x7F: Same as ASCII/WinAnsi
	0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
	0x0008, 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F,
	0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
	0x0018, 0x0019, 0x001A, 0x001B, 0x001C, 0x001D, 0x001E, 0x001F,
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
	0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F,
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
	0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F,
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
	0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F,
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
	0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F,
	0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
	0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F,
	0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
	0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000,

	// 0x80-0xFF: PDFDocEncoding specific (similar to WinAnsi but with differences)
	0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x0192, 0x2044, // 0x80-0x87 •†‡…—–ƒ⁄
	0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, // 0x88-0x8F ‹›−‰„""'
	0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x0141, 0x0152, 0x0160, // 0x90-0x97 '‚™ﬁﬂŁŒŠ
	0x0178, 0x017D, 0x0131, 0x0142, 0x0153, 0x0161, 0x017E, 0x0000, // 0x98-0x9F ŸŽıłœšž
	0x20AC, 0x00A1, 0x00A2, 0x00A3, 0x00A4, 0x00A5, 0x00A6, 0x00A7, // 0xA0-0xA7 €¡¢£¤¥¦§
	0x00A8, 0x00A9, 0x00AA, 0x00AB, 0x00AC, 0x0000, 0x00AE, 0x00AF, // 0xA8-0xAF ¨©ª«¬®¯
	0x00B0, 0x00B1, 0x00B2, 0x00B3, 0x00B4, 0x00B5, 0x00B6, 0x00B7, // 0xB0-0xB7 °±²³´µ¶·
	0x00B8, 0x00B9, 0x00BA, 0x00BB, 0x00BC, 0x00BD, 0x00BE, 0x00BF, // 0xB8-0xBF ¸¹º»¼½¾¿
	0x00C0, 0x00C1, 0x00C2, 0x00C3, 0x00C4, 0x00C5, 0x00C6, 0x00C7, // 0xC0-0xC7 ÀÁÂÃÄÅÆÇ
	0x00C8, 0x00C9, 0x00CA, 0x00CB, 0x00CC, 0x00CD, 0x00CE, 0x00CF, // 0xC8-0xCF ÈÉÊËÌÍÎÏ
	0x00D0, 0x00D1, 0x00D2, 0x00D3, 0x00D4, 0x00D5, 0x00D6, 0x00D7, // 0xD0-0xD7 ÐÑÒÓÔÕÖ×
	0x00D8, 0x00D9, 0x00DA, 0x00DB, 0x00DC, 0x00DD, 0x00DE, 0x00DF, // 0xD8-0xDF ØÙÚÛÜÝÞß
	0x00E0, 0x00E1, 0x00E2, 0x00E3, 0x00E4, 0x00E5, 0x00E6, 0x00E7, // 0xE0-0xE7 àáâãäåæç
	0x00E8, 0x00E9, 0x00EA, 0x00EB, 0x00EC, 0x00ED, 0x00EE, 0x00EF, // 0xE8-0xEF èéêëìíîï
	0x00F0, 0x00F1, 0x00F2, 0x00F3, 0x00F4, 0x00F5, 0x00F6, 0x00F7, // 0xF0-0xF7 ðñòóôõö÷
	0x00F8, 0x00F9, 0x00FA, 0x00FB, 0x00FC, 0x00FD, 0x00FE, 0x00FF, // 0xF8-0xFF øùúûüýþÿ
}

// standardEncodingTableData - Adobe StandardEncoding for Type1 fonts
// This is the default encoding for PostScript/Type1 fonts
var standardEncodingTableData = [256]rune{
	// 0x00-0x1F: Mostly unmapped in StandardEncoding
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

	// 0x20-0x7E: Standard ASCII
	0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x2019, // 0x20-0x27  !"#$%&'
	0x0028, 0x0029, 0x002A, 0x002B, 0x002C, 0x002D, 0x002E, 0x002F, // 0x28-0x2F ()*+,-./
	0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, // 0x30-0x37 01234567
	0x0038, 0x0039, 0x003A, 0x003B, 0x003C, 0x003D, 0x003E, 0x003F, // 0x38-0x3F 89:;<=>?
	0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, // 0x40-0x47 @ABCDEFG
	0x0048, 0x0049, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, // 0x48-0x4F HIJKLMNO
	0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, // 0x50-0x57 PQRSTUVW
	0x0058, 0x0059, 0x005A, 0x005B, 0x005C, 0x005D, 0x005E, 0x005F, // 0x58-0x5F XYZ[\]^_
	0x2018, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, // 0x60-0x67 `abcdefg
	0x0068, 0x0069, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, // 0x68-0x6F hijklmno
	0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, // 0x70-0x77 pqrstuvw
	0x0078, 0x0079, 0x007A, 0x007B, 0x007C, 0x007D, 0x007E, 0x0000, // 0x78-0x7F xyz{|}~

	// 0x80-0xFF: StandardEncoding extended characters (PostScript glyph names)
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x00A1, 0x00A2, 0x00A3, 0x2044, 0x00A5, 0x0192, 0x00A7, // 0xA0-0xA7  ¡¢£⁄¥ƒ§
	0x00A4, 0x0027, 0x201C, 0x00AB, 0x2039, 0x203A, 0xFB01, 0xFB02, // 0xA8-0xAF ¤'"«‹›ﬁﬂ
	0x0000, 0x2013, 0x2020, 0x2021, 0x00B7, 0x0000, 0x00B6, 0x2022, // 0xB0-0xB7 –†‡·¶•
	0x201A, 0x201E, 0x201D, 0x00BB, 0x2026, 0x2030, 0x0000, 0x00BF, // 0xB8-0xBF ‚„"»…‰¿
	0x0000, 0x0060, 0x00B4, 0x02C6, 0x02DC, 0x00AF, 0x02D8, 0x02D9, // 0xC0-0xC7 `´ˆ˜¯˘˙
	0x00A8, 0x0000, 0x02DA, 0x00B8, 0x0000, 0x02DD, 0x02DB, 0x02C7, // 0xC8-0xCF ¨˚¸˝˛ˇ
	0x2014, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0xD0-0xD7 —
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, // 0xD8-0xDF
	0x0000, 0x00C6, 0x0000, 0x00AA, 0x0000, 0x0000, 0x0000, 0x0000, // 0xE0-0xE7 Æª
	0x0141, 0x00D8, 0x0152, 0x00BA, 0x0000, 0x0000, 0x0000, 0x0000, // 0xE8-0xEF ŁØŒº
	0x0000, 0x00E6, 0x0000, 0x0000, 0x0000, 0x0131, 0x0000, 0x0000, // 0xF0-0xF7 æı
	0x0142, 0x00F8, 0x0153, 0x00DF, 0x0000, 0x0000, 0x0000, 0x0000, // 0xF8-0xFF łøœß
}

// IsValidUTF8 checks if a string is valid UTF-8
// This is useful for detecting UTF-16BE strings (which will fail UTF-8 validation)
func IsValidUTF8(s string) bool {
	return utf8.ValidString(s)
}

// glyphNameToUnicode maps PDF glyph names to Unicode code points
// This is used by NewCustomEncodingFromGlyphs to convert Differences arrays
// Reference: Adobe Glyph List Specification
var glyphNameToUnicode = map[string]rune{
	// Common punctuation and quotes
	"space":         0x0020,
	"exclam":        0x0021,
	"quotedbl":      0x0022,
	"numbersign":    0x0023,
	"dollar":        0x0024,
	"percent":       0x0025,
	"ampersand":     0x0026,
	"quotesingle":   0x0027,
	"quoteright":    0x2019, // '
	"quoteleft":     0x2018, // '
	"quotedblleft":  0x201C, // "
	"quotedblright": 0x201D, // "
	"parenleft":     0x0028,
	"parenright":    0x0029,
	"asterisk":      0x002A,
	"plus":          0x002B,
	"comma":         0x002C,
	"hyphen":        0x002D,
	"period":        0x002E,
	"slash":         0x002F,

	// Digits
	"zero":  0x0030,
	"one":   0x0031,
	"two":   0x0032,
	"three": 0x0033,
	"four":  0x0034,
	"five":  0x0035,
	"six":   0x0036,
	"seven": 0x0037,
	"eight": 0x0038,
	"nine":  0x0039,

	// Common symbols
	"colon":        0x003A,
	"semicolon":    0x003B,
	"less":         0x003C,
	"equal":        0x003D,
	"greater":      0x003E,
	"question":     0x003F,
	"at":           0x0040,
	"bracketleft":  0x005B,
	"backslash":    0x005C,
	"bracketright": 0x005D,
	"asciicircum":  0x005E,
	"underscore":   0x005F,
	"grave":        0x0060,
	"braceleft":    0x007B,
	"bar":          0x007C,
	"braceright":   0x007D,
	"asciitilde":   0x007E,

	// Uppercase letters
	"A": 0x0041, "B": 0x0042, "C": 0x0043, "D": 0x0044,
	"E": 0x0045, "F": 0x0046, "G": 0x0047, "H": 0x0048,
	"I": 0x0049, "J": 0x004A, "K": 0x004B, "L": 0x004C,
	"M": 0x004D, "N": 0x004E, "O": 0x004F, "P": 0x0050,
	"Q": 0x0051, "R": 0x0052, "S": 0x0053, "T": 0x0054,
	"U": 0x0055, "V": 0x0056, "W": 0x0057, "X": 0x0058,
	"Y": 0x0059, "Z": 0x005A,

	// Lowercase letters
	"a": 0x0061, "b": 0x0062, "c": 0x0063, "d": 0x0064,
	"e": 0x0065, "f": 0x0066, "g": 0x0067, "h": 0x0068,
	"i": 0x0069, "j": 0x006A, "k": 0x006B, "l": 0x006C,
	"m": 0x006D, "n": 0x006E, "o": 0x006F, "p": 0x0070,
	"q": 0x0071, "r": 0x0072, "s": 0x0073, "t": 0x0074,
	"u": 0x0075, "v": 0x0076, "w": 0x0077, "x": 0x0078,
	"y": 0x0079, "z": 0x007A,

	// Currency and special symbols
	"Euro":          0x20AC, // €
	"bullet":        0x2022, // •
	"dagger":        0x2020, // †
	"daggerdbl":     0x2021, // ‡
	"ellipsis":      0x2026, // …
	"emdash":        0x2014, // —
	"endash":        0x2013, // –
	"trademark":     0x2122, // ™
	"copyright":     0x00A9, // ©
	"registered":    0x00AE, // ®
	"cent":          0x00A2, // ¢
	"sterling":      0x00A3, // £
	"yen":           0x00A5, // ¥
	"florin":        0x0192, // ƒ
	"section":       0x00A7, // §
	"paragraph":     0x00B6, // ¶
	"degree":        0x00B0, // °
	"exclamdown":    0x00A1, // ¡
	"questiondown":  0x00BF, // ¿
	"guillemotleft": 0x00AB, // «
	"guillemotright": 0x00BB, // »
	"guilsinglleft":  0x2039, // ‹
	"guilsinglright": 0x203A, // ›

	// Accented characters - Latin-1 supplement
	"Agrave":   0x00C0, // À
	"Aacute":   0x00C1, // Á
	"Acircumflex": 0x00C2, // Â
	"Atilde":   0x00C3, // Ã
	"Adieresis": 0x00C4, // Ä
	"Aring":    0x00C5, // Å
	"AE":       0x00C6, // Æ
	"Ccedilla": 0x00C7, // Ç
	"Egrave":   0x00C8, // È
	"Eacute":   0x00C9, // É
	"Ecircumflex": 0x00CA, // Ê
	"Edieresis": 0x00CB, // Ë
	"Igrave":   0x00CC, // Ì
	"Iacute":   0x00CD, // Í
	"Icircumflex": 0x00CE, // Î
	"Idieresis": 0x00CF, // Ï
	"Eth":      0x00D0, // Ð
	"Ntilde":   0x00D1, // Ñ
	"Ograve":   0x00D2, // Ò
	"Oacute":   0x00D3, // Ó
	"Ocircumflex": 0x00D4, // Ô
	"Otilde":   0x00D5, // Õ
	"Odieresis": 0x00D6, // Ö
	"Oslash":   0x00D8, // Ø
	"Ugrave":   0x00D9, // Ù
	"Uacute":   0x00DA, // Ú
	"Ucircumflex": 0x00DB, // Û
	"Udieresis": 0x00DC, // Ü
	"Yacute":   0x00DD, // Ý
	"Thorn":    0x00DE, // Þ
	"germandbls": 0x00DF, // ß

	"agrave":   0x00E0, // à
	"aacute":   0x00E1, // á
	"acircumflex": 0x00E2, // â
	"atilde":   0x00E3, // ã
	"adieresis": 0x00E4, // ä
	"aring":    0x00E5, // å
	"ae":       0x00E6, // æ
	"ccedilla": 0x00E7, // ç
	"egrave":   0x00E8, // è
	"eacute":   0x00E9, // é
	"ecircumflex": 0x00EA, // ê
	"edieresis": 0x00EB, // ë
	"igrave":   0x00EC, // ì
	"iacute":   0x00ED, // í
	"icircumflex": 0x00EE, // î
	"idieresis": 0x00EF, // ï
	"eth":      0x00F0, // ð
	"ntilde":   0x00F1, // ñ
	"ograve":   0x00F2, // ò
	"oacute":   0x00F3, // ó
	"ocircumflex": 0x00F4, // ô
	"otilde":   0x00F5, // õ
	"odieresis": 0x00F6, // ö
	"oslash":   0x00F8, // ø
	"ugrave":   0x00F9, // ù
	"uacute":   0x00FA, // ú
	"ucircumflex": 0x00FB, // û
	"udieresis": 0x00FC, // ü
	"yacute":   0x00FD, // ý
	"thorn":    0x00FE, // þ
	"ydieresis": 0x00FF, // ÿ

	// Fractions
	"fraction":     0x2044, // ⁄
	"onehalf":      0x00BD, // ½
	"onequarter":   0x00BC, // ¼
	"threequarters": 0x00BE, // ¾

	// Math and technical
	"minus":       0x2212, // −
	"multiply":    0x00D7, // ×
	"divide":      0x00F7, // ÷
	"plusminus":   0x00B1, // ±
	"notequal":    0x2260, // ≠
	"lessequal":   0x2264, // ≤
	"greaterequal": 0x2265, // ≥
	"mu":          0x00B5, // µ
	"partialdiff": 0x2202, // ∂
	"summation":   0x2211, // ∑
	"product":     0x220F, // ∏
	"pi":          0x03C0, // π
	"integral":    0x222B, // ∫
	"Omega":       0x03A9, // Ω
	"infinity":    0x221E, // ∞
	"radical":     0x221A, // √
	"approxequal": 0x2248, // ≈
}
